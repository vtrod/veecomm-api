// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/vtrod/veecomm-api/ent/address"
	"github.com/vtrod/veecomm-api/ent/avaliation"
	"github.com/vtrod/veecomm-api/ent/cart"
	"github.com/vtrod/veecomm-api/ent/cartitem"
	"github.com/vtrod/veecomm-api/ent/category"
	"github.com/vtrod/veecomm-api/ent/coupon"
	"github.com/vtrod/veecomm-api/ent/order"
	"github.com/vtrod/veecomm-api/ent/orderitem"
	"github.com/vtrod/veecomm-api/ent/predicate"
	"github.com/vtrod/veecomm-api/ent/product"
	"github.com/vtrod/veecomm-api/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddress    = "Address"
	TypeAvaliation = "Avaliation"
	TypeCart       = "Cart"
	TypeCartItem   = "CartItem"
	TypeCategory   = "Category"
	TypeCoupon     = "Coupon"
	TypeOrder      = "Order"
	TypeOrderItem  = "OrderItem"
	TypeProduct    = "Product"
	TypeUser       = "User"
)

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op            Op
	typ           string
	id            *string
	cep           *string
	logradouro    *string
	numero        *string
	complemento   *string
	bairro        *string
	cidade        *string
	estado        *string
	is_default    *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	orders        map[string]struct{}
	removedorders map[string]struct{}
	clearedorders bool
	done          bool
	oldValue      func(context.Context) (*Address, error)
	predicates    []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id string) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Address entities.
func (m *AddressMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AddressMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AddressMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AddressMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[address.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AddressMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[address.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AddressMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, address.FieldUserID)
}

// SetCep sets the "cep" field.
func (m *AddressMutation) SetCep(s string) {
	m.cep = &s
}

// Cep returns the value of the "cep" field in the mutation.
func (m *AddressMutation) Cep() (r string, exists bool) {
	v := m.cep
	if v == nil {
		return
	}
	return *v, true
}

// OldCep returns the old "cep" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCep(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCep: %w", err)
	}
	return oldValue.Cep, nil
}

// ResetCep resets all changes to the "cep" field.
func (m *AddressMutation) ResetCep() {
	m.cep = nil
}

// SetLogradouro sets the "logradouro" field.
func (m *AddressMutation) SetLogradouro(s string) {
	m.logradouro = &s
}

// Logradouro returns the value of the "logradouro" field in the mutation.
func (m *AddressMutation) Logradouro() (r string, exists bool) {
	v := m.logradouro
	if v == nil {
		return
	}
	return *v, true
}

// OldLogradouro returns the old "logradouro" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldLogradouro(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogradouro is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogradouro requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogradouro: %w", err)
	}
	return oldValue.Logradouro, nil
}

// ResetLogradouro resets all changes to the "logradouro" field.
func (m *AddressMutation) ResetLogradouro() {
	m.logradouro = nil
}

// SetNumero sets the "numero" field.
func (m *AddressMutation) SetNumero(s string) {
	m.numero = &s
}

// Numero returns the value of the "numero" field in the mutation.
func (m *AddressMutation) Numero() (r string, exists bool) {
	v := m.numero
	if v == nil {
		return
	}
	return *v, true
}

// OldNumero returns the old "numero" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldNumero(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumero is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumero requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumero: %w", err)
	}
	return oldValue.Numero, nil
}

// ResetNumero resets all changes to the "numero" field.
func (m *AddressMutation) ResetNumero() {
	m.numero = nil
}

// SetComplemento sets the "complemento" field.
func (m *AddressMutation) SetComplemento(s string) {
	m.complemento = &s
}

// Complemento returns the value of the "complemento" field in the mutation.
func (m *AddressMutation) Complemento() (r string, exists bool) {
	v := m.complemento
	if v == nil {
		return
	}
	return *v, true
}

// OldComplemento returns the old "complemento" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldComplemento(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComplemento is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComplemento requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComplemento: %w", err)
	}
	return oldValue.Complemento, nil
}

// ClearComplemento clears the value of the "complemento" field.
func (m *AddressMutation) ClearComplemento() {
	m.complemento = nil
	m.clearedFields[address.FieldComplemento] = struct{}{}
}

// ComplementoCleared returns if the "complemento" field was cleared in this mutation.
func (m *AddressMutation) ComplementoCleared() bool {
	_, ok := m.clearedFields[address.FieldComplemento]
	return ok
}

// ResetComplemento resets all changes to the "complemento" field.
func (m *AddressMutation) ResetComplemento() {
	m.complemento = nil
	delete(m.clearedFields, address.FieldComplemento)
}

// SetBairro sets the "bairro" field.
func (m *AddressMutation) SetBairro(s string) {
	m.bairro = &s
}

// Bairro returns the value of the "bairro" field in the mutation.
func (m *AddressMutation) Bairro() (r string, exists bool) {
	v := m.bairro
	if v == nil {
		return
	}
	return *v, true
}

// OldBairro returns the old "bairro" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldBairro(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBairro is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBairro requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBairro: %w", err)
	}
	return oldValue.Bairro, nil
}

// ResetBairro resets all changes to the "bairro" field.
func (m *AddressMutation) ResetBairro() {
	m.bairro = nil
}

// SetCidade sets the "cidade" field.
func (m *AddressMutation) SetCidade(s string) {
	m.cidade = &s
}

// Cidade returns the value of the "cidade" field in the mutation.
func (m *AddressMutation) Cidade() (r string, exists bool) {
	v := m.cidade
	if v == nil {
		return
	}
	return *v, true
}

// OldCidade returns the old "cidade" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCidade(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCidade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCidade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidade: %w", err)
	}
	return oldValue.Cidade, nil
}

// ResetCidade resets all changes to the "cidade" field.
func (m *AddressMutation) ResetCidade() {
	m.cidade = nil
}

// SetEstado sets the "estado" field.
func (m *AddressMutation) SetEstado(s string) {
	m.estado = &s
}

// Estado returns the value of the "estado" field in the mutation.
func (m *AddressMutation) Estado() (r string, exists bool) {
	v := m.estado
	if v == nil {
		return
	}
	return *v, true
}

// OldEstado returns the old "estado" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldEstado(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstado is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstado requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstado: %w", err)
	}
	return oldValue.Estado, nil
}

// ResetEstado resets all changes to the "estado" field.
func (m *AddressMutation) ResetEstado() {
	m.estado = nil
}

// SetIsDefault sets the "is_default" field.
func (m *AddressMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *AddressMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *AddressMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *AddressMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[address.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AddressMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AddressMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *AddressMutation) AddOrderIDs(ids ...string) {
	if m.orders == nil {
		m.orders = make(map[string]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *AddressMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *AddressMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *AddressMutation) RemoveOrderIDs(ids ...string) {
	if m.removedorders == nil {
		m.removedorders = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *AddressMutation) RemovedOrdersIDs() (ids []string) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *AddressMutation) OrdersIDs() (ids []string) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *AddressMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Address, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, address.FieldUserID)
	}
	if m.cep != nil {
		fields = append(fields, address.FieldCep)
	}
	if m.logradouro != nil {
		fields = append(fields, address.FieldLogradouro)
	}
	if m.numero != nil {
		fields = append(fields, address.FieldNumero)
	}
	if m.complemento != nil {
		fields = append(fields, address.FieldComplemento)
	}
	if m.bairro != nil {
		fields = append(fields, address.FieldBairro)
	}
	if m.cidade != nil {
		fields = append(fields, address.FieldCidade)
	}
	if m.estado != nil {
		fields = append(fields, address.FieldEstado)
	}
	if m.is_default != nil {
		fields = append(fields, address.FieldIsDefault)
	}
	if m.created_at != nil {
		fields = append(fields, address.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, address.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldUserID:
		return m.UserID()
	case address.FieldCep:
		return m.Cep()
	case address.FieldLogradouro:
		return m.Logradouro()
	case address.FieldNumero:
		return m.Numero()
	case address.FieldComplemento:
		return m.Complemento()
	case address.FieldBairro:
		return m.Bairro()
	case address.FieldCidade:
		return m.Cidade()
	case address.FieldEstado:
		return m.Estado()
	case address.FieldIsDefault:
		return m.IsDefault()
	case address.FieldCreatedAt:
		return m.CreatedAt()
	case address.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldUserID:
		return m.OldUserID(ctx)
	case address.FieldCep:
		return m.OldCep(ctx)
	case address.FieldLogradouro:
		return m.OldLogradouro(ctx)
	case address.FieldNumero:
		return m.OldNumero(ctx)
	case address.FieldComplemento:
		return m.OldComplemento(ctx)
	case address.FieldBairro:
		return m.OldBairro(ctx)
	case address.FieldCidade:
		return m.OldCidade(ctx)
	case address.FieldEstado:
		return m.OldEstado(ctx)
	case address.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case address.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case address.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case address.FieldCep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCep(v)
		return nil
	case address.FieldLogradouro:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogradouro(v)
		return nil
	case address.FieldNumero:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumero(v)
		return nil
	case address.FieldComplemento:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComplemento(v)
		return nil
	case address.FieldBairro:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBairro(v)
		return nil
	case address.FieldCidade:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidade(v)
		return nil
	case address.FieldEstado:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstado(v)
		return nil
	case address.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case address.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case address.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldUserID) {
		fields = append(fields, address.FieldUserID)
	}
	if m.FieldCleared(address.FieldComplemento) {
		fields = append(fields, address.FieldComplemento)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldUserID:
		m.ClearUserID()
		return nil
	case address.FieldComplemento:
		m.ClearComplemento()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldUserID:
		m.ResetUserID()
		return nil
	case address.FieldCep:
		m.ResetCep()
		return nil
	case address.FieldLogradouro:
		m.ResetLogradouro()
		return nil
	case address.FieldNumero:
		m.ResetNumero()
		return nil
	case address.FieldComplemento:
		m.ResetComplemento()
		return nil
	case address.FieldBairro:
		m.ResetBairro()
		return nil
	case address.FieldCidade:
		m.ResetCidade()
		return nil
	case address.FieldEstado:
		m.ResetEstado()
		return nil
	case address.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case address.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case address.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, address.EdgeUser)
	}
	if m.orders != nil {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorders != nil {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, address.EdgeUser)
	}
	if m.clearedorders {
		edges = append(edges, address.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeUser:
		return m.cleareduser
	case address.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeUser:
		m.ResetUser()
		return nil
	case address.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AvaliationMutation represents an operation that mutates the Avaliation nodes in the graph.
type AvaliationMutation struct {
	config
	op             Op
	typ            string
	id             *string
	user_name      *string
	rating         *int
	addrating      *int
	comment        *string
	date           *time.Time
	images         *[]string
	appendimages   []string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	product        *string
	clearedproduct bool
	user           *string
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Avaliation, error)
	predicates     []predicate.Avaliation
}

var _ ent.Mutation = (*AvaliationMutation)(nil)

// avaliationOption allows management of the mutation configuration using functional options.
type avaliationOption func(*AvaliationMutation)

// newAvaliationMutation creates new mutation for the Avaliation entity.
func newAvaliationMutation(c config, op Op, opts ...avaliationOption) *AvaliationMutation {
	m := &AvaliationMutation{
		config:        c,
		op:            op,
		typ:           TypeAvaliation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAvaliationID sets the ID field of the mutation.
func withAvaliationID(id string) avaliationOption {
	return func(m *AvaliationMutation) {
		var (
			err   error
			once  sync.Once
			value *Avaliation
		)
		m.oldValue = func(ctx context.Context) (*Avaliation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Avaliation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAvaliation sets the old Avaliation of the mutation.
func withAvaliation(node *Avaliation) avaliationOption {
	return func(m *AvaliationMutation) {
		m.oldValue = func(context.Context) (*Avaliation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AvaliationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AvaliationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Avaliation entities.
func (m *AvaliationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AvaliationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AvaliationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Avaliation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProductID sets the "product_id" field.
func (m *AvaliationMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *AvaliationMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Avaliation entity.
// If the Avaliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AvaliationMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *AvaliationMutation) ClearProductID() {
	m.product = nil
	m.clearedFields[avaliation.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *AvaliationMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[avaliation.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *AvaliationMutation) ResetProductID() {
	m.product = nil
	delete(m.clearedFields, avaliation.FieldProductID)
}

// SetUserID sets the "user_id" field.
func (m *AvaliationMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AvaliationMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Avaliation entity.
// If the Avaliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AvaliationMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *AvaliationMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[avaliation.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *AvaliationMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[avaliation.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AvaliationMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, avaliation.FieldUserID)
}

// SetUserName sets the "user_name" field.
func (m *AvaliationMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *AvaliationMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the Avaliation entity.
// If the Avaliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AvaliationMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName resets all changes to the "user_name" field.
func (m *AvaliationMutation) ResetUserName() {
	m.user_name = nil
}

// SetRating sets the "rating" field.
func (m *AvaliationMutation) SetRating(i int) {
	m.rating = &i
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *AvaliationMutation) Rating() (r int, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Avaliation entity.
// If the Avaliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AvaliationMutation) OldRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds i to the "rating" field.
func (m *AvaliationMutation) AddRating(i int) {
	if m.addrating != nil {
		*m.addrating += i
	} else {
		m.addrating = &i
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *AvaliationMutation) AddedRating() (r int, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *AvaliationMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetComment sets the "comment" field.
func (m *AvaliationMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *AvaliationMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Avaliation entity.
// If the Avaliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AvaliationMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *AvaliationMutation) ResetComment() {
	m.comment = nil
}

// SetDate sets the "date" field.
func (m *AvaliationMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *AvaliationMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Avaliation entity.
// If the Avaliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AvaliationMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *AvaliationMutation) ResetDate() {
	m.date = nil
}

// SetImages sets the "images" field.
func (m *AvaliationMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *AvaliationMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Avaliation entity.
// If the Avaliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AvaliationMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *AvaliationMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *AvaliationMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *AvaliationMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[avaliation.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *AvaliationMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[avaliation.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *AvaliationMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, avaliation.FieldImages)
}

// SetCreatedAt sets the "created_at" field.
func (m *AvaliationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AvaliationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Avaliation entity.
// If the Avaliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AvaliationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AvaliationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AvaliationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AvaliationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Avaliation entity.
// If the Avaliation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AvaliationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AvaliationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *AvaliationMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[avaliation.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *AvaliationMutation) ProductCleared() bool {
	return m.ProductIDCleared() || m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *AvaliationMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *AvaliationMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *AvaliationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[avaliation.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AvaliationMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AvaliationMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AvaliationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AvaliationMutation builder.
func (m *AvaliationMutation) Where(ps ...predicate.Avaliation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AvaliationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AvaliationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Avaliation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AvaliationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AvaliationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Avaliation).
func (m *AvaliationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AvaliationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.product != nil {
		fields = append(fields, avaliation.FieldProductID)
	}
	if m.user != nil {
		fields = append(fields, avaliation.FieldUserID)
	}
	if m.user_name != nil {
		fields = append(fields, avaliation.FieldUserName)
	}
	if m.rating != nil {
		fields = append(fields, avaliation.FieldRating)
	}
	if m.comment != nil {
		fields = append(fields, avaliation.FieldComment)
	}
	if m.date != nil {
		fields = append(fields, avaliation.FieldDate)
	}
	if m.images != nil {
		fields = append(fields, avaliation.FieldImages)
	}
	if m.created_at != nil {
		fields = append(fields, avaliation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, avaliation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AvaliationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case avaliation.FieldProductID:
		return m.ProductID()
	case avaliation.FieldUserID:
		return m.UserID()
	case avaliation.FieldUserName:
		return m.UserName()
	case avaliation.FieldRating:
		return m.Rating()
	case avaliation.FieldComment:
		return m.Comment()
	case avaliation.FieldDate:
		return m.Date()
	case avaliation.FieldImages:
		return m.Images()
	case avaliation.FieldCreatedAt:
		return m.CreatedAt()
	case avaliation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AvaliationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case avaliation.FieldProductID:
		return m.OldProductID(ctx)
	case avaliation.FieldUserID:
		return m.OldUserID(ctx)
	case avaliation.FieldUserName:
		return m.OldUserName(ctx)
	case avaliation.FieldRating:
		return m.OldRating(ctx)
	case avaliation.FieldComment:
		return m.OldComment(ctx)
	case avaliation.FieldDate:
		return m.OldDate(ctx)
	case avaliation.FieldImages:
		return m.OldImages(ctx)
	case avaliation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case avaliation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Avaliation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AvaliationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case avaliation.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case avaliation.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case avaliation.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case avaliation.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case avaliation.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case avaliation.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case avaliation.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case avaliation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case avaliation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Avaliation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AvaliationMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, avaliation.FieldRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AvaliationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case avaliation.FieldRating:
		return m.AddedRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AvaliationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case avaliation.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	}
	return fmt.Errorf("unknown Avaliation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AvaliationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(avaliation.FieldProductID) {
		fields = append(fields, avaliation.FieldProductID)
	}
	if m.FieldCleared(avaliation.FieldUserID) {
		fields = append(fields, avaliation.FieldUserID)
	}
	if m.FieldCleared(avaliation.FieldImages) {
		fields = append(fields, avaliation.FieldImages)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AvaliationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AvaliationMutation) ClearField(name string) error {
	switch name {
	case avaliation.FieldProductID:
		m.ClearProductID()
		return nil
	case avaliation.FieldUserID:
		m.ClearUserID()
		return nil
	case avaliation.FieldImages:
		m.ClearImages()
		return nil
	}
	return fmt.Errorf("unknown Avaliation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AvaliationMutation) ResetField(name string) error {
	switch name {
	case avaliation.FieldProductID:
		m.ResetProductID()
		return nil
	case avaliation.FieldUserID:
		m.ResetUserID()
		return nil
	case avaliation.FieldUserName:
		m.ResetUserName()
		return nil
	case avaliation.FieldRating:
		m.ResetRating()
		return nil
	case avaliation.FieldComment:
		m.ResetComment()
		return nil
	case avaliation.FieldDate:
		m.ResetDate()
		return nil
	case avaliation.FieldImages:
		m.ResetImages()
		return nil
	case avaliation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case avaliation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Avaliation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AvaliationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product != nil {
		edges = append(edges, avaliation.EdgeProduct)
	}
	if m.user != nil {
		edges = append(edges, avaliation.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AvaliationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case avaliation.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case avaliation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AvaliationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AvaliationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AvaliationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct {
		edges = append(edges, avaliation.EdgeProduct)
	}
	if m.cleareduser {
		edges = append(edges, avaliation.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AvaliationMutation) EdgeCleared(name string) bool {
	switch name {
	case avaliation.EdgeProduct:
		return m.clearedproduct
	case avaliation.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AvaliationMutation) ClearEdge(name string) error {
	switch name {
	case avaliation.EdgeProduct:
		m.ClearProduct()
		return nil
	case avaliation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Avaliation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AvaliationMutation) ResetEdge(name string) error {
	switch name {
	case avaliation.EdgeProduct:
		m.ResetProduct()
		return nil
	case avaliation.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Avaliation edge %s", name)
}

// CartMutation represents an operation that mutates the Cart nodes in the graph.
type CartMutation struct {
	config
	op                Op
	typ               string
	id                *string
	subtotal          *float64
	addsubtotal       *float64
	shipping          *float64
	addshipping       *float64
	discount          *float64
	adddiscount       *float64
	total             *float64
	addtotal          *float64
	applied_coupon    *bool
	coupon_code       *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	user              *string
	cleareduser       bool
	cart_items        map[string]struct{}
	removedcart_items map[string]struct{}
	clearedcart_items bool
	done              bool
	oldValue          func(context.Context) (*Cart, error)
	predicates        []predicate.Cart
}

var _ ent.Mutation = (*CartMutation)(nil)

// cartOption allows management of the mutation configuration using functional options.
type cartOption func(*CartMutation)

// newCartMutation creates new mutation for the Cart entity.
func newCartMutation(c config, op Op, opts ...cartOption) *CartMutation {
	m := &CartMutation{
		config:        c,
		op:            op,
		typ:           TypeCart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCartID sets the ID field of the mutation.
func withCartID(id string) cartOption {
	return func(m *CartMutation) {
		var (
			err   error
			once  sync.Once
			value *Cart
		)
		m.oldValue = func(ctx context.Context) (*Cart, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cart.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCart sets the old Cart of the mutation.
func withCart(node *Cart) cartOption {
	return func(m *CartMutation) {
		m.oldValue = func(context.Context) (*Cart, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cart entities.
func (m *CartMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CartMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CartMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cart.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *CartMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CartMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CartMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[cart.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CartMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[cart.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CartMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, cart.FieldUserID)
}

// SetSubtotal sets the "subtotal" field.
func (m *CartMutation) SetSubtotal(f float64) {
	m.subtotal = &f
	m.addsubtotal = nil
}

// Subtotal returns the value of the "subtotal" field in the mutation.
func (m *CartMutation) Subtotal() (r float64, exists bool) {
	v := m.subtotal
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtotal returns the old "subtotal" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldSubtotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtotal: %w", err)
	}
	return oldValue.Subtotal, nil
}

// AddSubtotal adds f to the "subtotal" field.
func (m *CartMutation) AddSubtotal(f float64) {
	if m.addsubtotal != nil {
		*m.addsubtotal += f
	} else {
		m.addsubtotal = &f
	}
}

// AddedSubtotal returns the value that was added to the "subtotal" field in this mutation.
func (m *CartMutation) AddedSubtotal() (r float64, exists bool) {
	v := m.addsubtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubtotal resets all changes to the "subtotal" field.
func (m *CartMutation) ResetSubtotal() {
	m.subtotal = nil
	m.addsubtotal = nil
}

// SetShipping sets the "shipping" field.
func (m *CartMutation) SetShipping(f float64) {
	m.shipping = &f
	m.addshipping = nil
}

// Shipping returns the value of the "shipping" field in the mutation.
func (m *CartMutation) Shipping() (r float64, exists bool) {
	v := m.shipping
	if v == nil {
		return
	}
	return *v, true
}

// OldShipping returns the old "shipping" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldShipping(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipping: %w", err)
	}
	return oldValue.Shipping, nil
}

// AddShipping adds f to the "shipping" field.
func (m *CartMutation) AddShipping(f float64) {
	if m.addshipping != nil {
		*m.addshipping += f
	} else {
		m.addshipping = &f
	}
}

// AddedShipping returns the value that was added to the "shipping" field in this mutation.
func (m *CartMutation) AddedShipping() (r float64, exists bool) {
	v := m.addshipping
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipping clears the value of the "shipping" field.
func (m *CartMutation) ClearShipping() {
	m.shipping = nil
	m.addshipping = nil
	m.clearedFields[cart.FieldShipping] = struct{}{}
}

// ShippingCleared returns if the "shipping" field was cleared in this mutation.
func (m *CartMutation) ShippingCleared() bool {
	_, ok := m.clearedFields[cart.FieldShipping]
	return ok
}

// ResetShipping resets all changes to the "shipping" field.
func (m *CartMutation) ResetShipping() {
	m.shipping = nil
	m.addshipping = nil
	delete(m.clearedFields, cart.FieldShipping)
}

// SetDiscount sets the "discount" field.
func (m *CartMutation) SetDiscount(f float64) {
	m.discount = &f
	m.adddiscount = nil
}

// Discount returns the value of the "discount" field in the mutation.
func (m *CartMutation) Discount() (r float64, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldDiscount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// AddDiscount adds f to the "discount" field.
func (m *CartMutation) AddDiscount(f float64) {
	if m.adddiscount != nil {
		*m.adddiscount += f
	} else {
		m.adddiscount = &f
	}
}

// AddedDiscount returns the value that was added to the "discount" field in this mutation.
func (m *CartMutation) AddedDiscount() (r float64, exists bool) {
	v := m.adddiscount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscount resets all changes to the "discount" field.
func (m *CartMutation) ResetDiscount() {
	m.discount = nil
	m.adddiscount = nil
}

// SetTotal sets the "total" field.
func (m *CartMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *CartMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *CartMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *CartMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *CartMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetAppliedCoupon sets the "applied_coupon" field.
func (m *CartMutation) SetAppliedCoupon(b bool) {
	m.applied_coupon = &b
}

// AppliedCoupon returns the value of the "applied_coupon" field in the mutation.
func (m *CartMutation) AppliedCoupon() (r bool, exists bool) {
	v := m.applied_coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldAppliedCoupon returns the old "applied_coupon" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldAppliedCoupon(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppliedCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppliedCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppliedCoupon: %w", err)
	}
	return oldValue.AppliedCoupon, nil
}

// ResetAppliedCoupon resets all changes to the "applied_coupon" field.
func (m *CartMutation) ResetAppliedCoupon() {
	m.applied_coupon = nil
}

// SetCouponCode sets the "coupon_code" field.
func (m *CartMutation) SetCouponCode(s string) {
	m.coupon_code = &s
}

// CouponCode returns the value of the "coupon_code" field in the mutation.
func (m *CartMutation) CouponCode() (r string, exists bool) {
	v := m.coupon_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponCode returns the old "coupon_code" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldCouponCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponCode: %w", err)
	}
	return oldValue.CouponCode, nil
}

// ClearCouponCode clears the value of the "coupon_code" field.
func (m *CartMutation) ClearCouponCode() {
	m.coupon_code = nil
	m.clearedFields[cart.FieldCouponCode] = struct{}{}
}

// CouponCodeCleared returns if the "coupon_code" field was cleared in this mutation.
func (m *CartMutation) CouponCodeCleared() bool {
	_, ok := m.clearedFields[cart.FieldCouponCode]
	return ok
}

// ResetCouponCode resets all changes to the "coupon_code" field.
func (m *CartMutation) ResetCouponCode() {
	m.coupon_code = nil
	delete(m.clearedFields, cart.FieldCouponCode)
}

// SetCreatedAt sets the "created_at" field.
func (m *CartMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CartMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CartMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CartMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CartMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cart entity.
// If the Cart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CartMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CartMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[cart.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CartMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CartMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CartMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCartItemIDs adds the "cart_items" edge to the CartItem entity by ids.
func (m *CartMutation) AddCartItemIDs(ids ...string) {
	if m.cart_items == nil {
		m.cart_items = make(map[string]struct{})
	}
	for i := range ids {
		m.cart_items[ids[i]] = struct{}{}
	}
}

// ClearCartItems clears the "cart_items" edge to the CartItem entity.
func (m *CartMutation) ClearCartItems() {
	m.clearedcart_items = true
}

// CartItemsCleared reports if the "cart_items" edge to the CartItem entity was cleared.
func (m *CartMutation) CartItemsCleared() bool {
	return m.clearedcart_items
}

// RemoveCartItemIDs removes the "cart_items" edge to the CartItem entity by IDs.
func (m *CartMutation) RemoveCartItemIDs(ids ...string) {
	if m.removedcart_items == nil {
		m.removedcart_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.cart_items, ids[i])
		m.removedcart_items[ids[i]] = struct{}{}
	}
}

// RemovedCartItems returns the removed IDs of the "cart_items" edge to the CartItem entity.
func (m *CartMutation) RemovedCartItemsIDs() (ids []string) {
	for id := range m.removedcart_items {
		ids = append(ids, id)
	}
	return
}

// CartItemsIDs returns the "cart_items" edge IDs in the mutation.
func (m *CartMutation) CartItemsIDs() (ids []string) {
	for id := range m.cart_items {
		ids = append(ids, id)
	}
	return
}

// ResetCartItems resets all changes to the "cart_items" edge.
func (m *CartMutation) ResetCartItems() {
	m.cart_items = nil
	m.clearedcart_items = false
	m.removedcart_items = nil
}

// Where appends a list predicates to the CartMutation builder.
func (m *CartMutation) Where(ps ...predicate.Cart) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CartMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CartMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cart, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CartMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CartMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cart).
func (m *CartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CartMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user != nil {
		fields = append(fields, cart.FieldUserID)
	}
	if m.subtotal != nil {
		fields = append(fields, cart.FieldSubtotal)
	}
	if m.shipping != nil {
		fields = append(fields, cart.FieldShipping)
	}
	if m.discount != nil {
		fields = append(fields, cart.FieldDiscount)
	}
	if m.total != nil {
		fields = append(fields, cart.FieldTotal)
	}
	if m.applied_coupon != nil {
		fields = append(fields, cart.FieldAppliedCoupon)
	}
	if m.coupon_code != nil {
		fields = append(fields, cart.FieldCouponCode)
	}
	if m.created_at != nil {
		fields = append(fields, cart.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cart.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cart.FieldUserID:
		return m.UserID()
	case cart.FieldSubtotal:
		return m.Subtotal()
	case cart.FieldShipping:
		return m.Shipping()
	case cart.FieldDiscount:
		return m.Discount()
	case cart.FieldTotal:
		return m.Total()
	case cart.FieldAppliedCoupon:
		return m.AppliedCoupon()
	case cart.FieldCouponCode:
		return m.CouponCode()
	case cart.FieldCreatedAt:
		return m.CreatedAt()
	case cart.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cart.FieldUserID:
		return m.OldUserID(ctx)
	case cart.FieldSubtotal:
		return m.OldSubtotal(ctx)
	case cart.FieldShipping:
		return m.OldShipping(ctx)
	case cart.FieldDiscount:
		return m.OldDiscount(ctx)
	case cart.FieldTotal:
		return m.OldTotal(ctx)
	case cart.FieldAppliedCoupon:
		return m.OldAppliedCoupon(ctx)
	case cart.FieldCouponCode:
		return m.OldCouponCode(ctx)
	case cart.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cart.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Cart field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cart.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case cart.FieldSubtotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtotal(v)
		return nil
	case cart.FieldShipping:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipping(v)
		return nil
	case cart.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case cart.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case cart.FieldAppliedCoupon:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppliedCoupon(v)
		return nil
	case cart.FieldCouponCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponCode(v)
		return nil
	case cart.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cart.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Cart field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CartMutation) AddedFields() []string {
	var fields []string
	if m.addsubtotal != nil {
		fields = append(fields, cart.FieldSubtotal)
	}
	if m.addshipping != nil {
		fields = append(fields, cart.FieldShipping)
	}
	if m.adddiscount != nil {
		fields = append(fields, cart.FieldDiscount)
	}
	if m.addtotal != nil {
		fields = append(fields, cart.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CartMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cart.FieldSubtotal:
		return m.AddedSubtotal()
	case cart.FieldShipping:
		return m.AddedShipping()
	case cart.FieldDiscount:
		return m.AddedDiscount()
	case cart.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cart.FieldSubtotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubtotal(v)
		return nil
	case cart.FieldShipping:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipping(v)
		return nil
	case cart.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscount(v)
		return nil
	case cart.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Cart numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CartMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cart.FieldUserID) {
		fields = append(fields, cart.FieldUserID)
	}
	if m.FieldCleared(cart.FieldShipping) {
		fields = append(fields, cart.FieldShipping)
	}
	if m.FieldCleared(cart.FieldCouponCode) {
		fields = append(fields, cart.FieldCouponCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CartMutation) ClearField(name string) error {
	switch name {
	case cart.FieldUserID:
		m.ClearUserID()
		return nil
	case cart.FieldShipping:
		m.ClearShipping()
		return nil
	case cart.FieldCouponCode:
		m.ClearCouponCode()
		return nil
	}
	return fmt.Errorf("unknown Cart nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CartMutation) ResetField(name string) error {
	switch name {
	case cart.FieldUserID:
		m.ResetUserID()
		return nil
	case cart.FieldSubtotal:
		m.ResetSubtotal()
		return nil
	case cart.FieldShipping:
		m.ResetShipping()
		return nil
	case cart.FieldDiscount:
		m.ResetDiscount()
		return nil
	case cart.FieldTotal:
		m.ResetTotal()
		return nil
	case cart.FieldAppliedCoupon:
		m.ResetAppliedCoupon()
		return nil
	case cart.FieldCouponCode:
		m.ResetCouponCode()
		return nil
	case cart.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cart.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Cart field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CartMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, cart.EdgeUser)
	}
	if m.cart_items != nil {
		edges = append(edges, cart.EdgeCartItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cart.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case cart.EdgeCartItems:
		ids := make([]ent.Value, 0, len(m.cart_items))
		for id := range m.cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcart_items != nil {
		edges = append(edges, cart.EdgeCartItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CartMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cart.EdgeCartItems:
		ids := make([]ent.Value, 0, len(m.removedcart_items))
		for id := range m.removedcart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, cart.EdgeUser)
	}
	if m.clearedcart_items {
		edges = append(edges, cart.EdgeCartItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CartMutation) EdgeCleared(name string) bool {
	switch name {
	case cart.EdgeUser:
		return m.cleareduser
	case cart.EdgeCartItems:
		return m.clearedcart_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CartMutation) ClearEdge(name string) error {
	switch name {
	case cart.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Cart unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CartMutation) ResetEdge(name string) error {
	switch name {
	case cart.EdgeUser:
		m.ResetUser()
		return nil
	case cart.EdgeCartItems:
		m.ResetCartItems()
		return nil
	}
	return fmt.Errorf("unknown Cart edge %s", name)
}

// CartItemMutation represents an operation that mutates the CartItem nodes in the graph.
type CartItemMutation struct {
	config
	op             Op
	typ            string
	id             *string
	name           *string
	price          *float64
	addprice       *float64
	image          *string
	quantity       *int
	addquantity    *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	cart           *string
	clearedcart    bool
	product        *string
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*CartItem, error)
	predicates     []predicate.CartItem
}

var _ ent.Mutation = (*CartItemMutation)(nil)

// cartitemOption allows management of the mutation configuration using functional options.
type cartitemOption func(*CartItemMutation)

// newCartItemMutation creates new mutation for the CartItem entity.
func newCartItemMutation(c config, op Op, opts ...cartitemOption) *CartItemMutation {
	m := &CartItemMutation{
		config:        c,
		op:            op,
		typ:           TypeCartItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCartItemID sets the ID field of the mutation.
func withCartItemID(id string) cartitemOption {
	return func(m *CartItemMutation) {
		var (
			err   error
			once  sync.Once
			value *CartItem
		)
		m.oldValue = func(ctx context.Context) (*CartItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CartItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCartItem sets the old CartItem of the mutation.
func withCartItem(node *CartItem) cartitemOption {
	return func(m *CartItemMutation) {
		m.oldValue = func(context.Context) (*CartItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CartItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CartItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CartItem entities.
func (m *CartItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CartItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CartItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CartItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCartID sets the "cart_id" field.
func (m *CartItemMutation) SetCartID(s string) {
	m.cart = &s
}

// CartID returns the value of the "cart_id" field in the mutation.
func (m *CartItemMutation) CartID() (r string, exists bool) {
	v := m.cart
	if v == nil {
		return
	}
	return *v, true
}

// OldCartID returns the old "cart_id" field's value of the CartItem entity.
// If the CartItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartItemMutation) OldCartID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCartID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCartID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCartID: %w", err)
	}
	return oldValue.CartID, nil
}

// ClearCartID clears the value of the "cart_id" field.
func (m *CartItemMutation) ClearCartID() {
	m.cart = nil
	m.clearedFields[cartitem.FieldCartID] = struct{}{}
}

// CartIDCleared returns if the "cart_id" field was cleared in this mutation.
func (m *CartItemMutation) CartIDCleared() bool {
	_, ok := m.clearedFields[cartitem.FieldCartID]
	return ok
}

// ResetCartID resets all changes to the "cart_id" field.
func (m *CartItemMutation) ResetCartID() {
	m.cart = nil
	delete(m.clearedFields, cartitem.FieldCartID)
}

// SetProductID sets the "product_id" field.
func (m *CartItemMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *CartItemMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the CartItem entity.
// If the CartItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartItemMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *CartItemMutation) ClearProductID() {
	m.product = nil
	m.clearedFields[cartitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *CartItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[cartitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *CartItemMutation) ResetProductID() {
	m.product = nil
	delete(m.clearedFields, cartitem.FieldProductID)
}

// SetName sets the "name" field.
func (m *CartItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CartItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CartItem entity.
// If the CartItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CartItemMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *CartItemMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *CartItemMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the CartItem entity.
// If the CartItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartItemMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *CartItemMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *CartItemMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *CartItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetImage sets the "image" field.
func (m *CartItemMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *CartItemMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the CartItem entity.
// If the CartItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartItemMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *CartItemMutation) ResetImage() {
	m.image = nil
}

// SetQuantity sets the "quantity" field.
func (m *CartItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *CartItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the CartItem entity.
// If the CartItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *CartItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *CartItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *CartItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CartItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CartItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CartItem entity.
// If the CartItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CartItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CartItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CartItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CartItem entity.
// If the CartItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CartItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CartItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearCart clears the "cart" edge to the Cart entity.
func (m *CartItemMutation) ClearCart() {
	m.clearedcart = true
	m.clearedFields[cartitem.FieldCartID] = struct{}{}
}

// CartCleared reports if the "cart" edge to the Cart entity was cleared.
func (m *CartItemMutation) CartCleared() bool {
	return m.CartIDCleared() || m.clearedcart
}

// CartIDs returns the "cart" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CartID instead. It exists only for internal usage by the builders.
func (m *CartItemMutation) CartIDs() (ids []string) {
	if id := m.cart; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCart resets all changes to the "cart" edge.
func (m *CartItemMutation) ResetCart() {
	m.cart = nil
	m.clearedcart = false
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *CartItemMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[cartitem.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *CartItemMutation) ProductCleared() bool {
	return m.ProductIDCleared() || m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *CartItemMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *CartItemMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the CartItemMutation builder.
func (m *CartItemMutation) Where(ps ...predicate.CartItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CartItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CartItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CartItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CartItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CartItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CartItem).
func (m *CartItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CartItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.cart != nil {
		fields = append(fields, cartitem.FieldCartID)
	}
	if m.product != nil {
		fields = append(fields, cartitem.FieldProductID)
	}
	if m.name != nil {
		fields = append(fields, cartitem.FieldName)
	}
	if m.price != nil {
		fields = append(fields, cartitem.FieldPrice)
	}
	if m.image != nil {
		fields = append(fields, cartitem.FieldImage)
	}
	if m.quantity != nil {
		fields = append(fields, cartitem.FieldQuantity)
	}
	if m.created_at != nil {
		fields = append(fields, cartitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cartitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CartItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cartitem.FieldCartID:
		return m.CartID()
	case cartitem.FieldProductID:
		return m.ProductID()
	case cartitem.FieldName:
		return m.Name()
	case cartitem.FieldPrice:
		return m.Price()
	case cartitem.FieldImage:
		return m.Image()
	case cartitem.FieldQuantity:
		return m.Quantity()
	case cartitem.FieldCreatedAt:
		return m.CreatedAt()
	case cartitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CartItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cartitem.FieldCartID:
		return m.OldCartID(ctx)
	case cartitem.FieldProductID:
		return m.OldProductID(ctx)
	case cartitem.FieldName:
		return m.OldName(ctx)
	case cartitem.FieldPrice:
		return m.OldPrice(ctx)
	case cartitem.FieldImage:
		return m.OldImage(ctx)
	case cartitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case cartitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cartitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CartItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cartitem.FieldCartID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCartID(v)
		return nil
	case cartitem.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case cartitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cartitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case cartitem.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case cartitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case cartitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cartitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CartItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CartItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, cartitem.FieldPrice)
	}
	if m.addquantity != nil {
		fields = append(fields, cartitem.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CartItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cartitem.FieldPrice:
		return m.AddedPrice()
	case cartitem.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CartItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cartitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case cartitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown CartItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CartItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cartitem.FieldCartID) {
		fields = append(fields, cartitem.FieldCartID)
	}
	if m.FieldCleared(cartitem.FieldProductID) {
		fields = append(fields, cartitem.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CartItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CartItemMutation) ClearField(name string) error {
	switch name {
	case cartitem.FieldCartID:
		m.ClearCartID()
		return nil
	case cartitem.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown CartItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CartItemMutation) ResetField(name string) error {
	switch name {
	case cartitem.FieldCartID:
		m.ResetCartID()
		return nil
	case cartitem.FieldProductID:
		m.ResetProductID()
		return nil
	case cartitem.FieldName:
		m.ResetName()
		return nil
	case cartitem.FieldPrice:
		m.ResetPrice()
		return nil
	case cartitem.FieldImage:
		m.ResetImage()
		return nil
	case cartitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case cartitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cartitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CartItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CartItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cart != nil {
		edges = append(edges, cartitem.EdgeCart)
	}
	if m.product != nil {
		edges = append(edges, cartitem.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CartItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cartitem.EdgeCart:
		if id := m.cart; id != nil {
			return []ent.Value{*id}
		}
	case cartitem.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CartItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CartItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CartItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcart {
		edges = append(edges, cartitem.EdgeCart)
	}
	if m.clearedproduct {
		edges = append(edges, cartitem.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CartItemMutation) EdgeCleared(name string) bool {
	switch name {
	case cartitem.EdgeCart:
		return m.clearedcart
	case cartitem.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CartItemMutation) ClearEdge(name string) error {
	switch name {
	case cartitem.EdgeCart:
		m.ClearCart()
		return nil
	case cartitem.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown CartItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CartItemMutation) ResetEdge(name string) error {
	switch name {
	case cartitem.EdgeCart:
		m.ResetCart()
		return nil
	case cartitem.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown CartItem edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	name            *string
	slug            *string
	image           *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	products        map[string]struct{}
	removedproducts map[string]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*Category, error)
	predicates      []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id string) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *CategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *CategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *CategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetImage sets the "image" field.
func (m *CategoryMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *CategoryMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *CategoryMutation) ClearImage() {
	m.image = nil
	m.clearedFields[category.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *CategoryMutation) ImageCleared() bool {
	_, ok := m.clearedFields[category.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *CategoryMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, category.FieldImage)
}

// SetCreatedAt sets the "created_at" field.
func (m *CategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *CategoryMutation) AddProductIDs(ids ...string) {
	if m.products == nil {
		m.products = make(map[string]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *CategoryMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *CategoryMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *CategoryMutation) RemoveProductIDs(ids ...string) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *CategoryMutation) RemovedProductsIDs() (ids []string) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *CategoryMutation) ProductsIDs() (ids []string) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *CategoryMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, category.FieldSlug)
	}
	if m.image != nil {
		fields = append(fields, category.FieldImage)
	}
	if m.created_at != nil {
		fields = append(fields, category.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, category.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldSlug:
		return m.Slug()
	case category.FieldImage:
		return m.Image()
	case category.FieldCreatedAt:
		return m.CreatedAt()
	case category.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldSlug:
		return m.OldSlug(ctx)
	case category.FieldImage:
		return m.OldImage(ctx)
	case category.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case category.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case category.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case category.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case category.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldImage) {
		fields = append(fields, category.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldSlug:
		m.ResetSlug()
		return nil
	case category.FieldImage:
		m.ResetImage()
		return nil
	case category.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case category.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.products != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproducts != nil {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproducts {
		edges = append(edges, category.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CouponMutation represents an operation that mutates the Coupon nodes in the graph.
type CouponMutation struct {
	config
	op              Op
	typ             string
	id              *string
	code            *string
	_type           *coupon.Type
	value           *float64
	addvalue        *float64
	min_purchase    *float64
	addmin_purchase *float64
	usage_limit     *int
	addusage_limit  *int
	used_count      *int
	addused_count   *int
	expires_at      *time.Time
	active          *bool
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Coupon, error)
	predicates      []predicate.Coupon
}

var _ ent.Mutation = (*CouponMutation)(nil)

// couponOption allows management of the mutation configuration using functional options.
type couponOption func(*CouponMutation)

// newCouponMutation creates new mutation for the Coupon entity.
func newCouponMutation(c config, op Op, opts ...couponOption) *CouponMutation {
	m := &CouponMutation{
		config:        c,
		op:            op,
		typ:           TypeCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponID sets the ID field of the mutation.
func withCouponID(id string) couponOption {
	return func(m *CouponMutation) {
		var (
			err   error
			once  sync.Once
			value *Coupon
		)
		m.oldValue = func(ctx context.Context) (*Coupon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoupon sets the old Coupon of the mutation.
func withCoupon(node *Coupon) couponOption {
	return func(m *CouponMutation) {
		m.oldValue = func(context.Context) (*Coupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Coupon entities.
func (m *CouponMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coupon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *CouponMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CouponMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CouponMutation) ResetCode() {
	m.code = nil
}

// SetType sets the "type" field.
func (m *CouponMutation) SetType(c coupon.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CouponMutation) GetType() (r coupon.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldType(ctx context.Context) (v coupon.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CouponMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *CouponMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *CouponMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *CouponMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *CouponMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *CouponMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetMinPurchase sets the "min_purchase" field.
func (m *CouponMutation) SetMinPurchase(f float64) {
	m.min_purchase = &f
	m.addmin_purchase = nil
}

// MinPurchase returns the value of the "min_purchase" field in the mutation.
func (m *CouponMutation) MinPurchase() (r float64, exists bool) {
	v := m.min_purchase
	if v == nil {
		return
	}
	return *v, true
}

// OldMinPurchase returns the old "min_purchase" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldMinPurchase(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinPurchase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinPurchase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinPurchase: %w", err)
	}
	return oldValue.MinPurchase, nil
}

// AddMinPurchase adds f to the "min_purchase" field.
func (m *CouponMutation) AddMinPurchase(f float64) {
	if m.addmin_purchase != nil {
		*m.addmin_purchase += f
	} else {
		m.addmin_purchase = &f
	}
}

// AddedMinPurchase returns the value that was added to the "min_purchase" field in this mutation.
func (m *CouponMutation) AddedMinPurchase() (r float64, exists bool) {
	v := m.addmin_purchase
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinPurchase clears the value of the "min_purchase" field.
func (m *CouponMutation) ClearMinPurchase() {
	m.min_purchase = nil
	m.addmin_purchase = nil
	m.clearedFields[coupon.FieldMinPurchase] = struct{}{}
}

// MinPurchaseCleared returns if the "min_purchase" field was cleared in this mutation.
func (m *CouponMutation) MinPurchaseCleared() bool {
	_, ok := m.clearedFields[coupon.FieldMinPurchase]
	return ok
}

// ResetMinPurchase resets all changes to the "min_purchase" field.
func (m *CouponMutation) ResetMinPurchase() {
	m.min_purchase = nil
	m.addmin_purchase = nil
	delete(m.clearedFields, coupon.FieldMinPurchase)
}

// SetUsageLimit sets the "usage_limit" field.
func (m *CouponMutation) SetUsageLimit(i int) {
	m.usage_limit = &i
	m.addusage_limit = nil
}

// UsageLimit returns the value of the "usage_limit" field in the mutation.
func (m *CouponMutation) UsageLimit() (r int, exists bool) {
	v := m.usage_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageLimit returns the old "usage_limit" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUsageLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageLimit: %w", err)
	}
	return oldValue.UsageLimit, nil
}

// AddUsageLimit adds i to the "usage_limit" field.
func (m *CouponMutation) AddUsageLimit(i int) {
	if m.addusage_limit != nil {
		*m.addusage_limit += i
	} else {
		m.addusage_limit = &i
	}
}

// AddedUsageLimit returns the value that was added to the "usage_limit" field in this mutation.
func (m *CouponMutation) AddedUsageLimit() (r int, exists bool) {
	v := m.addusage_limit
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsageLimit clears the value of the "usage_limit" field.
func (m *CouponMutation) ClearUsageLimit() {
	m.usage_limit = nil
	m.addusage_limit = nil
	m.clearedFields[coupon.FieldUsageLimit] = struct{}{}
}

// UsageLimitCleared returns if the "usage_limit" field was cleared in this mutation.
func (m *CouponMutation) UsageLimitCleared() bool {
	_, ok := m.clearedFields[coupon.FieldUsageLimit]
	return ok
}

// ResetUsageLimit resets all changes to the "usage_limit" field.
func (m *CouponMutation) ResetUsageLimit() {
	m.usage_limit = nil
	m.addusage_limit = nil
	delete(m.clearedFields, coupon.FieldUsageLimit)
}

// SetUsedCount sets the "used_count" field.
func (m *CouponMutation) SetUsedCount(i int) {
	m.used_count = &i
	m.addused_count = nil
}

// UsedCount returns the value of the "used_count" field in the mutation.
func (m *CouponMutation) UsedCount() (r int, exists bool) {
	v := m.used_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedCount returns the old "used_count" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUsedCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedCount: %w", err)
	}
	return oldValue.UsedCount, nil
}

// AddUsedCount adds i to the "used_count" field.
func (m *CouponMutation) AddUsedCount(i int) {
	if m.addused_count != nil {
		*m.addused_count += i
	} else {
		m.addused_count = &i
	}
}

// AddedUsedCount returns the value that was added to the "used_count" field in this mutation.
func (m *CouponMutation) AddedUsedCount() (r int, exists bool) {
	v := m.addused_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedCount resets all changes to the "used_count" field.
func (m *CouponMutation) ResetUsedCount() {
	m.used_count = nil
	m.addused_count = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *CouponMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *CouponMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *CouponMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[coupon.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *CouponMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[coupon.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *CouponMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, coupon.FieldExpiresAt)
}

// SetActive sets the "active" field.
func (m *CouponMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *CouponMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *CouponMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the CouponMutation builder.
func (m *CouponMutation) Where(ps ...predicate.Coupon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Coupon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Coupon).
func (m *CouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.code != nil {
		fields = append(fields, coupon.FieldCode)
	}
	if m._type != nil {
		fields = append(fields, coupon.FieldType)
	}
	if m.value != nil {
		fields = append(fields, coupon.FieldValue)
	}
	if m.min_purchase != nil {
		fields = append(fields, coupon.FieldMinPurchase)
	}
	if m.usage_limit != nil {
		fields = append(fields, coupon.FieldUsageLimit)
	}
	if m.used_count != nil {
		fields = append(fields, coupon.FieldUsedCount)
	}
	if m.expires_at != nil {
		fields = append(fields, coupon.FieldExpiresAt)
	}
	if m.active != nil {
		fields = append(fields, coupon.FieldActive)
	}
	if m.created_at != nil {
		fields = append(fields, coupon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coupon.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldCode:
		return m.Code()
	case coupon.FieldType:
		return m.GetType()
	case coupon.FieldValue:
		return m.Value()
	case coupon.FieldMinPurchase:
		return m.MinPurchase()
	case coupon.FieldUsageLimit:
		return m.UsageLimit()
	case coupon.FieldUsedCount:
		return m.UsedCount()
	case coupon.FieldExpiresAt:
		return m.ExpiresAt()
	case coupon.FieldActive:
		return m.Active()
	case coupon.FieldCreatedAt:
		return m.CreatedAt()
	case coupon.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupon.FieldCode:
		return m.OldCode(ctx)
	case coupon.FieldType:
		return m.OldType(ctx)
	case coupon.FieldValue:
		return m.OldValue(ctx)
	case coupon.FieldMinPurchase:
		return m.OldMinPurchase(ctx)
	case coupon.FieldUsageLimit:
		return m.OldUsageLimit(ctx)
	case coupon.FieldUsedCount:
		return m.OldUsedCount(ctx)
	case coupon.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case coupon.FieldActive:
		return m.OldActive(ctx)
	case coupon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coupon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Coupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case coupon.FieldType:
		v, ok := value.(coupon.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case coupon.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case coupon.FieldMinPurchase:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinPurchase(v)
		return nil
	case coupon.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageLimit(v)
		return nil
	case coupon.FieldUsedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedCount(v)
		return nil
	case coupon.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case coupon.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case coupon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coupon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, coupon.FieldValue)
	}
	if m.addmin_purchase != nil {
		fields = append(fields, coupon.FieldMinPurchase)
	}
	if m.addusage_limit != nil {
		fields = append(fields, coupon.FieldUsageLimit)
	}
	if m.addused_count != nil {
		fields = append(fields, coupon.FieldUsedCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldValue:
		return m.AddedValue()
	case coupon.FieldMinPurchase:
		return m.AddedMinPurchase()
	case coupon.FieldUsageLimit:
		return m.AddedUsageLimit()
	case coupon.FieldUsedCount:
		return m.AddedUsedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case coupon.FieldMinPurchase:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinPurchase(v)
		return nil
	case coupon.FieldUsageLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageLimit(v)
		return nil
	case coupon.FieldUsedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedCount(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupon.FieldMinPurchase) {
		fields = append(fields, coupon.FieldMinPurchase)
	}
	if m.FieldCleared(coupon.FieldUsageLimit) {
		fields = append(fields, coupon.FieldUsageLimit)
	}
	if m.FieldCleared(coupon.FieldExpiresAt) {
		fields = append(fields, coupon.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponMutation) ClearField(name string) error {
	switch name {
	case coupon.FieldMinPurchase:
		m.ClearMinPurchase()
		return nil
	case coupon.FieldUsageLimit:
		m.ClearUsageLimit()
		return nil
	case coupon.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Coupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponMutation) ResetField(name string) error {
	switch name {
	case coupon.FieldCode:
		m.ResetCode()
		return nil
	case coupon.FieldType:
		m.ResetType()
		return nil
	case coupon.FieldValue:
		m.ResetValue()
		return nil
	case coupon.FieldMinPurchase:
		m.ResetMinPurchase()
		return nil
	case coupon.FieldUsageLimit:
		m.ResetUsageLimit()
		return nil
	case coupon.FieldUsedCount:
		m.ResetUsedCount()
		return nil
	case coupon.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case coupon.FieldActive:
		m.ResetActive()
		return nil
	case coupon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coupon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Coupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Coupon edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	date               *time.Time
	total              *float64
	addtotal           *float64
	shipping           *float64
	addshipping        *float64
	discount           *float64
	adddiscount        *float64
	delivery_type      *order.DeliveryType
	status             *order.Status
	payment_method     *string
	payment_status     *string
	coupon_code        *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	address            *string
	clearedaddress     bool
	order_items        map[string]struct{}
	removedorder_items map[string]struct{}
	clearedorder_items bool
	done               bool
	oldValue           func(context.Context) (*Order, error)
	predicates         []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id string) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *OrderMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *OrderMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[order.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OrderMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[order.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, order.FieldUserID)
}

// SetDate sets the "date" field.
func (m *OrderMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *OrderMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *OrderMutation) ResetDate() {
	m.date = nil
}

// SetTotal sets the "total" field.
func (m *OrderMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *OrderMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *OrderMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *OrderMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *OrderMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetShipping sets the "shipping" field.
func (m *OrderMutation) SetShipping(f float64) {
	m.shipping = &f
	m.addshipping = nil
}

// Shipping returns the value of the "shipping" field in the mutation.
func (m *OrderMutation) Shipping() (r float64, exists bool) {
	v := m.shipping
	if v == nil {
		return
	}
	return *v, true
}

// OldShipping returns the old "shipping" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldShipping(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipping: %w", err)
	}
	return oldValue.Shipping, nil
}

// AddShipping adds f to the "shipping" field.
func (m *OrderMutation) AddShipping(f float64) {
	if m.addshipping != nil {
		*m.addshipping += f
	} else {
		m.addshipping = &f
	}
}

// AddedShipping returns the value that was added to the "shipping" field in this mutation.
func (m *OrderMutation) AddedShipping() (r float64, exists bool) {
	v := m.addshipping
	if v == nil {
		return
	}
	return *v, true
}

// ResetShipping resets all changes to the "shipping" field.
func (m *OrderMutation) ResetShipping() {
	m.shipping = nil
	m.addshipping = nil
}

// SetDiscount sets the "discount" field.
func (m *OrderMutation) SetDiscount(f float64) {
	m.discount = &f
	m.adddiscount = nil
}

// Discount returns the value of the "discount" field in the mutation.
func (m *OrderMutation) Discount() (r float64, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDiscount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// AddDiscount adds f to the "discount" field.
func (m *OrderMutation) AddDiscount(f float64) {
	if m.adddiscount != nil {
		*m.adddiscount += f
	} else {
		m.adddiscount = &f
	}
}

// AddedDiscount returns the value that was added to the "discount" field in this mutation.
func (m *OrderMutation) AddedDiscount() (r float64, exists bool) {
	v := m.adddiscount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscount resets all changes to the "discount" field.
func (m *OrderMutation) ResetDiscount() {
	m.discount = nil
	m.adddiscount = nil
}

// SetDeliveryType sets the "delivery_type" field.
func (m *OrderMutation) SetDeliveryType(ot order.DeliveryType) {
	m.delivery_type = &ot
}

// DeliveryType returns the value of the "delivery_type" field in the mutation.
func (m *OrderMutation) DeliveryType() (r order.DeliveryType, exists bool) {
	v := m.delivery_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryType returns the old "delivery_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeliveryType(ctx context.Context) (v order.DeliveryType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryType: %w", err)
	}
	return oldValue.DeliveryType, nil
}

// ResetDeliveryType resets all changes to the "delivery_type" field.
func (m *OrderMutation) ResetDeliveryType() {
	m.delivery_type = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetAddressID sets the "address_id" field.
func (m *OrderMutation) SetAddressID(s string) {
	m.address = &s
}

// AddressID returns the value of the "address_id" field in the mutation.
func (m *OrderMutation) AddressID() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressID returns the old "address_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAddressID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressID: %w", err)
	}
	return oldValue.AddressID, nil
}

// ClearAddressID clears the value of the "address_id" field.
func (m *OrderMutation) ClearAddressID() {
	m.address = nil
	m.clearedFields[order.FieldAddressID] = struct{}{}
}

// AddressIDCleared returns if the "address_id" field was cleared in this mutation.
func (m *OrderMutation) AddressIDCleared() bool {
	_, ok := m.clearedFields[order.FieldAddressID]
	return ok
}

// ResetAddressID resets all changes to the "address_id" field.
func (m *OrderMutation) ResetAddressID() {
	m.address = nil
	delete(m.clearedFields, order.FieldAddressID)
}

// SetPaymentMethod sets the "payment_method" field.
func (m *OrderMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *OrderMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaymentMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *OrderMutation) ResetPaymentMethod() {
	m.payment_method = nil
}

// SetPaymentStatus sets the "payment_status" field.
func (m *OrderMutation) SetPaymentStatus(s string) {
	m.payment_status = &s
}

// PaymentStatus returns the value of the "payment_status" field in the mutation.
func (m *OrderMutation) PaymentStatus() (r string, exists bool) {
	v := m.payment_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentStatus returns the old "payment_status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaymentStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentStatus: %w", err)
	}
	return oldValue.PaymentStatus, nil
}

// ResetPaymentStatus resets all changes to the "payment_status" field.
func (m *OrderMutation) ResetPaymentStatus() {
	m.payment_status = nil
}

// SetCouponCode sets the "coupon_code" field.
func (m *OrderMutation) SetCouponCode(s string) {
	m.coupon_code = &s
}

// CouponCode returns the value of the "coupon_code" field in the mutation.
func (m *OrderMutation) CouponCode() (r string, exists bool) {
	v := m.coupon_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponCode returns the old "coupon_code" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCouponCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponCode: %w", err)
	}
	return oldValue.CouponCode, nil
}

// ClearCouponCode clears the value of the "coupon_code" field.
func (m *OrderMutation) ClearCouponCode() {
	m.coupon_code = nil
	m.clearedFields[order.FieldCouponCode] = struct{}{}
}

// CouponCodeCleared returns if the "coupon_code" field was cleared in this mutation.
func (m *OrderMutation) CouponCodeCleared() bool {
	_, ok := m.clearedFields[order.FieldCouponCode]
	return ok
}

// ResetCouponCode resets all changes to the "coupon_code" field.
func (m *OrderMutation) ResetCouponCode() {
	m.coupon_code = nil
	delete(m.clearedFields, order.FieldCouponCode)
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[order.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrderMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *OrderMutation) ClearAddress() {
	m.clearedaddress = true
	m.clearedFields[order.FieldAddressID] = struct{}{}
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *OrderMutation) AddressCleared() bool {
	return m.AddressIDCleared() || m.clearedaddress
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) AddressIDs() (ids []string) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *OrderMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *OrderMutation) AddOrderItemIDs(ids ...string) {
	if m.order_items == nil {
		m.order_items = make(map[string]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *OrderMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *OrderMutation) RemoveOrderItemIDs(ids ...string) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.order_items, ids[i])
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *OrderMutation) RemovedOrderItemsIDs() (ids []string) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *OrderMutation) OrderItemsIDs() (ids []string) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *OrderMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.date != nil {
		fields = append(fields, order.FieldDate)
	}
	if m.total != nil {
		fields = append(fields, order.FieldTotal)
	}
	if m.shipping != nil {
		fields = append(fields, order.FieldShipping)
	}
	if m.discount != nil {
		fields = append(fields, order.FieldDiscount)
	}
	if m.delivery_type != nil {
		fields = append(fields, order.FieldDeliveryType)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.address != nil {
		fields = append(fields, order.FieldAddressID)
	}
	if m.payment_method != nil {
		fields = append(fields, order.FieldPaymentMethod)
	}
	if m.payment_status != nil {
		fields = append(fields, order.FieldPaymentStatus)
	}
	if m.coupon_code != nil {
		fields = append(fields, order.FieldCouponCode)
	}
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldUserID:
		return m.UserID()
	case order.FieldDate:
		return m.Date()
	case order.FieldTotal:
		return m.Total()
	case order.FieldShipping:
		return m.Shipping()
	case order.FieldDiscount:
		return m.Discount()
	case order.FieldDeliveryType:
		return m.DeliveryType()
	case order.FieldStatus:
		return m.Status()
	case order.FieldAddressID:
		return m.AddressID()
	case order.FieldPaymentMethod:
		return m.PaymentMethod()
	case order.FieldPaymentStatus:
		return m.PaymentStatus()
	case order.FieldCouponCode:
		return m.CouponCode()
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldUserID:
		return m.OldUserID(ctx)
	case order.FieldDate:
		return m.OldDate(ctx)
	case order.FieldTotal:
		return m.OldTotal(ctx)
	case order.FieldShipping:
		return m.OldShipping(ctx)
	case order.FieldDiscount:
		return m.OldDiscount(ctx)
	case order.FieldDeliveryType:
		return m.OldDeliveryType(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldAddressID:
		return m.OldAddressID(ctx)
	case order.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case order.FieldPaymentStatus:
		return m.OldPaymentStatus(ctx)
	case order.FieldCouponCode:
		return m.OldCouponCode(ctx)
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case order.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case order.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case order.FieldShipping:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipping(v)
		return nil
	case order.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case order.FieldDeliveryType:
		v, ok := value.(order.DeliveryType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryType(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldAddressID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressID(v)
		return nil
	case order.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case order.FieldPaymentStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentStatus(v)
		return nil
	case order.FieldCouponCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponCode(v)
		return nil
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addtotal != nil {
		fields = append(fields, order.FieldTotal)
	}
	if m.addshipping != nil {
		fields = append(fields, order.FieldShipping)
	}
	if m.adddiscount != nil {
		fields = append(fields, order.FieldDiscount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldTotal:
		return m.AddedTotal()
	case order.FieldShipping:
		return m.AddedShipping()
	case order.FieldDiscount:
		return m.AddedDiscount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case order.FieldShipping:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipping(v)
		return nil
	case order.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscount(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldUserID) {
		fields = append(fields, order.FieldUserID)
	}
	if m.FieldCleared(order.FieldAddressID) {
		fields = append(fields, order.FieldAddressID)
	}
	if m.FieldCleared(order.FieldCouponCode) {
		fields = append(fields, order.FieldCouponCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldUserID:
		m.ClearUserID()
		return nil
	case order.FieldAddressID:
		m.ClearAddressID()
		return nil
	case order.FieldCouponCode:
		m.ClearCouponCode()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldUserID:
		m.ResetUserID()
		return nil
	case order.FieldDate:
		m.ResetDate()
		return nil
	case order.FieldTotal:
		m.ResetTotal()
		return nil
	case order.FieldShipping:
		m.ResetShipping()
		return nil
	case order.FieldDiscount:
		m.ResetDiscount()
		return nil
	case order.FieldDeliveryType:
		m.ResetDeliveryType()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldAddressID:
		m.ResetAddressID()
		return nil
	case order.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case order.FieldPaymentStatus:
		m.ResetPaymentStatus()
		return nil
	case order.FieldCouponCode:
		m.ResetCouponCode()
		return nil
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, order.EdgeUser)
	}
	if m.address != nil {
		edges = append(edges, order.EdgeAddress)
	}
	if m.order_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorder_items != nil {
		edges = append(edges, order.EdgeOrderItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, order.EdgeUser)
	}
	if m.clearedaddress {
		edges = append(edges, order.EdgeAddress)
	}
	if m.clearedorder_items {
		edges = append(edges, order.EdgeOrderItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeUser:
		return m.cleareduser
	case order.EdgeAddress:
		return m.clearedaddress
	case order.EdgeOrderItems:
		return m.clearedorder_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ClearUser()
		return nil
	case order.EdgeAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ResetUser()
		return nil
	case order.EdgeAddress:
		m.ResetAddress()
		return nil
	case order.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op             Op
	typ            string
	id             *string
	name           *string
	price          *float64
	addprice       *float64
	image          *string
	quantity       *int
	addquantity    *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	_order         *string
	cleared_order  bool
	product        *string
	clearedproduct bool
	done           bool
	oldValue       func(context.Context) (*OrderItem, error)
	predicates     []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id string) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderItem entities.
func (m *OrderItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OrderItemMutation) SetOrderID(s string) {
	m._order = &s
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderItemMutation) OrderID() (r string, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderItemMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderItemMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderItemMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, orderitem.FieldOrderID)
}

// SetProductID sets the "product_id" field.
func (m *OrderItemMutation) SetProductID(s string) {
	m.product = &s
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderItemMutation) ProductID() (r string, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *OrderItemMutation) ClearProductID() {
	m.product = nil
	m.clearedFields[orderitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *OrderItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderItemMutation) ResetProductID() {
	m.product = nil
	delete(m.clearedFields, orderitem.FieldProductID)
}

// SetName sets the "name" field.
func (m *OrderItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrderItemMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *OrderItemMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderItemMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *OrderItemMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *OrderItemMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetImage sets the "image" field.
func (m *OrderItemMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *OrderItemMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *OrderItemMutation) ResetImage() {
	m.image = nil
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *OrderItemMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderItemMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderItemMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderitem.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderItemMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderIDs() (ids []string) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderItemMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *OrderItemMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[orderitem.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *OrderItemMutation) ProductCleared() bool {
	return m.ProductIDCleared() || m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) ProductIDs() (ids []string) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *OrderItemMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the OrderItemMutation builder.
func (m *OrderItemMutation) Where(ps ...predicate.OrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._order != nil {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.product != nil {
		fields = append(fields, orderitem.FieldProductID)
	}
	if m.name != nil {
		fields = append(fields, orderitem.FieldName)
	}
	if m.price != nil {
		fields = append(fields, orderitem.FieldPrice)
	}
	if m.image != nil {
		fields = append(fields, orderitem.FieldImage)
	}
	if m.quantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.created_at != nil {
		fields = append(fields, orderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldOrderID:
		return m.OrderID()
	case orderitem.FieldProductID:
		return m.ProductID()
	case orderitem.FieldName:
		return m.Name()
	case orderitem.FieldPrice:
		return m.Price()
	case orderitem.FieldImage:
		return m.Image()
	case orderitem.FieldQuantity:
		return m.Quantity()
	case orderitem.FieldCreatedAt:
		return m.CreatedAt()
	case orderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderitem.FieldProductID:
		return m.OldProductID(ctx)
	case orderitem.FieldName:
		return m.OldName(ctx)
	case orderitem.FieldPrice:
		return m.OldPrice(ctx)
	case orderitem.FieldImage:
		return m.OldImage(ctx)
	case orderitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderitem.FieldProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orderitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case orderitem.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, orderitem.FieldPrice)
	}
	if m.addquantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldPrice:
		return m.AddedPrice()
	case orderitem.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case orderitem.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldOrderID) {
		fields = append(fields, orderitem.FieldOrderID)
	}
	if m.FieldCleared(orderitem.FieldProductID) {
		fields = append(fields, orderitem.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case orderitem.FieldName:
		m.ResetName()
		return nil
	case orderitem.FieldPrice:
		m.ResetPrice()
		return nil
	case orderitem.FieldImage:
		m.ResetImage()
		return nil
	case orderitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.product != nil {
		edges = append(edges, orderitem.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, orderitem.EdgeOrder)
	}
	if m.clearedproduct {
		edges = append(edges, orderitem.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrder:
		return m.cleared_order
	case orderitem.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ClearOrder()
		return nil
	case orderitem.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrder:
		m.ResetOrder()
		return nil
	case orderitem.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	slug               *string
	description        *string
	price              *float64
	addprice           *float64
	sale_price         *float64
	addsale_price      *float64
	on_sale            *bool
	stock              *int
	addstock           *int
	sku                *string
	images             *[]string
	appendimages       []string
	rating             *float64
	addrating          *float64
	review_count       *int
	addreview_count    *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	avaliations        map[string]struct{}
	removedavaliations map[string]struct{}
	clearedavaliations bool
	category           *string
	clearedcategory    bool
	order_items        map[string]struct{}
	removedorder_items map[string]struct{}
	clearedorder_items bool
	cart_items         map[string]struct{}
	removedcart_items  map[string]struct{}
	clearedcart_items  bool
	done               bool
	oldValue           func(context.Context) (*Product, error)
	predicates         []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id string) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *ProductMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ProductMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ProductMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
}

// SetPrice sets the "price" field.
func (m *ProductMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetSalePrice sets the "sale_price" field.
func (m *ProductMutation) SetSalePrice(f float64) {
	m.sale_price = &f
	m.addsale_price = nil
}

// SalePrice returns the value of the "sale_price" field in the mutation.
func (m *ProductMutation) SalePrice() (r float64, exists bool) {
	v := m.sale_price
	if v == nil {
		return
	}
	return *v, true
}

// OldSalePrice returns the old "sale_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSalePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalePrice: %w", err)
	}
	return oldValue.SalePrice, nil
}

// AddSalePrice adds f to the "sale_price" field.
func (m *ProductMutation) AddSalePrice(f float64) {
	if m.addsale_price != nil {
		*m.addsale_price += f
	} else {
		m.addsale_price = &f
	}
}

// AddedSalePrice returns the value that was added to the "sale_price" field in this mutation.
func (m *ProductMutation) AddedSalePrice() (r float64, exists bool) {
	v := m.addsale_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalePrice clears the value of the "sale_price" field.
func (m *ProductMutation) ClearSalePrice() {
	m.sale_price = nil
	m.addsale_price = nil
	m.clearedFields[product.FieldSalePrice] = struct{}{}
}

// SalePriceCleared returns if the "sale_price" field was cleared in this mutation.
func (m *ProductMutation) SalePriceCleared() bool {
	_, ok := m.clearedFields[product.FieldSalePrice]
	return ok
}

// ResetSalePrice resets all changes to the "sale_price" field.
func (m *ProductMutation) ResetSalePrice() {
	m.sale_price = nil
	m.addsale_price = nil
	delete(m.clearedFields, product.FieldSalePrice)
}

// SetOnSale sets the "on_sale" field.
func (m *ProductMutation) SetOnSale(b bool) {
	m.on_sale = &b
}

// OnSale returns the value of the "on_sale" field in the mutation.
func (m *ProductMutation) OnSale() (r bool, exists bool) {
	v := m.on_sale
	if v == nil {
		return
	}
	return *v, true
}

// OldOnSale returns the old "on_sale" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldOnSale(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnSale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnSale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnSale: %w", err)
	}
	return oldValue.OnSale, nil
}

// ResetOnSale resets all changes to the "on_sale" field.
func (m *ProductMutation) ResetOnSale() {
	m.on_sale = nil
}

// SetStock sets the "stock" field.
func (m *ProductMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *ProductMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *ProductMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *ProductMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *ProductMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetSku sets the "sku" field.
func (m *ProductMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *ProductMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *ProductMutation) ResetSku() {
	m.sku = nil
}

// SetCategoryID sets the "category_id" field.
func (m *ProductMutation) SetCategoryID(s string) {
	m.category = &s
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *ProductMutation) CategoryID() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCategoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *ProductMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[product.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *ProductMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[product.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *ProductMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, product.FieldCategoryID)
}

// SetImages sets the "images" field.
func (m *ProductMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *ProductMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *ProductMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *ProductMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ResetImages resets all changes to the "images" field.
func (m *ProductMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
}

// SetRating sets the "rating" field.
func (m *ProductMutation) SetRating(f float64) {
	m.rating = &f
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *ProductMutation) Rating() (r float64, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds f to the "rating" field.
func (m *ProductMutation) AddRating(f float64) {
	if m.addrating != nil {
		*m.addrating += f
	} else {
		m.addrating = &f
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *ProductMutation) AddedRating() (r float64, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *ProductMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetReviewCount sets the "review_count" field.
func (m *ProductMutation) SetReviewCount(i int) {
	m.review_count = &i
	m.addreview_count = nil
}

// ReviewCount returns the value of the "review_count" field in the mutation.
func (m *ProductMutation) ReviewCount() (r int, exists bool) {
	v := m.review_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewCount returns the old "review_count" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldReviewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewCount: %w", err)
	}
	return oldValue.ReviewCount, nil
}

// AddReviewCount adds i to the "review_count" field.
func (m *ProductMutation) AddReviewCount(i int) {
	if m.addreview_count != nil {
		*m.addreview_count += i
	} else {
		m.addreview_count = &i
	}
}

// AddedReviewCount returns the value that was added to the "review_count" field in this mutation.
func (m *ProductMutation) AddedReviewCount() (r int, exists bool) {
	v := m.addreview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReviewCount resets all changes to the "review_count" field.
func (m *ProductMutation) ResetReviewCount() {
	m.review_count = nil
	m.addreview_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAvaliationIDs adds the "avaliations" edge to the Avaliation entity by ids.
func (m *ProductMutation) AddAvaliationIDs(ids ...string) {
	if m.avaliations == nil {
		m.avaliations = make(map[string]struct{})
	}
	for i := range ids {
		m.avaliations[ids[i]] = struct{}{}
	}
}

// ClearAvaliations clears the "avaliations" edge to the Avaliation entity.
func (m *ProductMutation) ClearAvaliations() {
	m.clearedavaliations = true
}

// AvaliationsCleared reports if the "avaliations" edge to the Avaliation entity was cleared.
func (m *ProductMutation) AvaliationsCleared() bool {
	return m.clearedavaliations
}

// RemoveAvaliationIDs removes the "avaliations" edge to the Avaliation entity by IDs.
func (m *ProductMutation) RemoveAvaliationIDs(ids ...string) {
	if m.removedavaliations == nil {
		m.removedavaliations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.avaliations, ids[i])
		m.removedavaliations[ids[i]] = struct{}{}
	}
}

// RemovedAvaliations returns the removed IDs of the "avaliations" edge to the Avaliation entity.
func (m *ProductMutation) RemovedAvaliationsIDs() (ids []string) {
	for id := range m.removedavaliations {
		ids = append(ids, id)
	}
	return
}

// AvaliationsIDs returns the "avaliations" edge IDs in the mutation.
func (m *ProductMutation) AvaliationsIDs() (ids []string) {
	for id := range m.avaliations {
		ids = append(ids, id)
	}
	return
}

// ResetAvaliations resets all changes to the "avaliations" edge.
func (m *ProductMutation) ResetAvaliations() {
	m.avaliations = nil
	m.clearedavaliations = false
	m.removedavaliations = nil
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *ProductMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[product.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *ProductMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CategoryIDs() (ids []string) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ProductMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *ProductMutation) AddOrderItemIDs(ids ...string) {
	if m.order_items == nil {
		m.order_items = make(map[string]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *ProductMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *ProductMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *ProductMutation) RemoveOrderItemIDs(ids ...string) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.order_items, ids[i])
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *ProductMutation) RemovedOrderItemsIDs() (ids []string) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *ProductMutation) OrderItemsIDs() (ids []string) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *ProductMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// AddCartItemIDs adds the "cart_items" edge to the CartItem entity by ids.
func (m *ProductMutation) AddCartItemIDs(ids ...string) {
	if m.cart_items == nil {
		m.cart_items = make(map[string]struct{})
	}
	for i := range ids {
		m.cart_items[ids[i]] = struct{}{}
	}
}

// ClearCartItems clears the "cart_items" edge to the CartItem entity.
func (m *ProductMutation) ClearCartItems() {
	m.clearedcart_items = true
}

// CartItemsCleared reports if the "cart_items" edge to the CartItem entity was cleared.
func (m *ProductMutation) CartItemsCleared() bool {
	return m.clearedcart_items
}

// RemoveCartItemIDs removes the "cart_items" edge to the CartItem entity by IDs.
func (m *ProductMutation) RemoveCartItemIDs(ids ...string) {
	if m.removedcart_items == nil {
		m.removedcart_items = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.cart_items, ids[i])
		m.removedcart_items[ids[i]] = struct{}{}
	}
}

// RemovedCartItems returns the removed IDs of the "cart_items" edge to the CartItem entity.
func (m *ProductMutation) RemovedCartItemsIDs() (ids []string) {
	for id := range m.removedcart_items {
		ids = append(ids, id)
	}
	return
}

// CartItemsIDs returns the "cart_items" edge IDs in the mutation.
func (m *ProductMutation) CartItemsIDs() (ids []string) {
	for id := range m.cart_items {
		ids = append(ids, id)
	}
	return
}

// ResetCartItems resets all changes to the "cart_items" edge.
func (m *ProductMutation) ResetCartItems() {
	m.cart_items = nil
	m.clearedcart_items = false
	m.removedcart_items = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, product.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.sale_price != nil {
		fields = append(fields, product.FieldSalePrice)
	}
	if m.on_sale != nil {
		fields = append(fields, product.FieldOnSale)
	}
	if m.stock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.sku != nil {
		fields = append(fields, product.FieldSku)
	}
	if m.category != nil {
		fields = append(fields, product.FieldCategoryID)
	}
	if m.images != nil {
		fields = append(fields, product.FieldImages)
	}
	if m.rating != nil {
		fields = append(fields, product.FieldRating)
	}
	if m.review_count != nil {
		fields = append(fields, product.FieldReviewCount)
	}
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldName:
		return m.Name()
	case product.FieldSlug:
		return m.Slug()
	case product.FieldDescription:
		return m.Description()
	case product.FieldPrice:
		return m.Price()
	case product.FieldSalePrice:
		return m.SalePrice()
	case product.FieldOnSale:
		return m.OnSale()
	case product.FieldStock:
		return m.Stock()
	case product.FieldSku:
		return m.Sku()
	case product.FieldCategoryID:
		return m.CategoryID()
	case product.FieldImages:
		return m.Images()
	case product.FieldRating:
		return m.Rating()
	case product.FieldReviewCount:
		return m.ReviewCount()
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldSlug:
		return m.OldSlug(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldPrice:
		return m.OldPrice(ctx)
	case product.FieldSalePrice:
		return m.OldSalePrice(ctx)
	case product.FieldOnSale:
		return m.OldOnSale(ctx)
	case product.FieldStock:
		return m.OldStock(ctx)
	case product.FieldSku:
		return m.OldSku(ctx)
	case product.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case product.FieldImages:
		return m.OldImages(ctx)
	case product.FieldRating:
		return m.OldRating(ctx)
	case product.FieldReviewCount:
		return m.OldReviewCount(ctx)
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case product.FieldSalePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalePrice(v)
		return nil
	case product.FieldOnSale:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnSale(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case product.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case product.FieldCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case product.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case product.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case product.FieldReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewCount(v)
		return nil
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, product.FieldPrice)
	}
	if m.addsale_price != nil {
		fields = append(fields, product.FieldSalePrice)
	}
	if m.addstock != nil {
		fields = append(fields, product.FieldStock)
	}
	if m.addrating != nil {
		fields = append(fields, product.FieldRating)
	}
	if m.addreview_count != nil {
		fields = append(fields, product.FieldReviewCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldPrice:
		return m.AddedPrice()
	case product.FieldSalePrice:
		return m.AddedSalePrice()
	case product.FieldStock:
		return m.AddedStock()
	case product.FieldRating:
		return m.AddedRating()
	case product.FieldReviewCount:
		return m.AddedReviewCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case product.FieldSalePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalePrice(v)
		return nil
	case product.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case product.FieldRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	case product.FieldReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewCount(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldSalePrice) {
		fields = append(fields, product.FieldSalePrice)
	}
	if m.FieldCleared(product.FieldCategoryID) {
		fields = append(fields, product.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldSalePrice:
		m.ClearSalePrice()
		return nil
	case product.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldSlug:
		m.ResetSlug()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldPrice:
		m.ResetPrice()
		return nil
	case product.FieldSalePrice:
		m.ResetSalePrice()
		return nil
	case product.FieldOnSale:
		m.ResetOnSale()
		return nil
	case product.FieldStock:
		m.ResetStock()
		return nil
	case product.FieldSku:
		m.ResetSku()
		return nil
	case product.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case product.FieldImages:
		m.ResetImages()
		return nil
	case product.FieldRating:
		m.ResetRating()
		return nil
	case product.FieldReviewCount:
		m.ResetReviewCount()
		return nil
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.avaliations != nil {
		edges = append(edges, product.EdgeAvaliations)
	}
	if m.category != nil {
		edges = append(edges, product.EdgeCategory)
	}
	if m.order_items != nil {
		edges = append(edges, product.EdgeOrderItems)
	}
	if m.cart_items != nil {
		edges = append(edges, product.EdgeCartItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeAvaliations:
		ids := make([]ent.Value, 0, len(m.avaliations))
		for id := range m.avaliations {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeCartItems:
		ids := make([]ent.Value, 0, len(m.cart_items))
		for id := range m.cart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedavaliations != nil {
		edges = append(edges, product.EdgeAvaliations)
	}
	if m.removedorder_items != nil {
		edges = append(edges, product.EdgeOrderItems)
	}
	if m.removedcart_items != nil {
		edges = append(edges, product.EdgeCartItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeAvaliations:
		ids := make([]ent.Value, 0, len(m.removedavaliations))
		for id := range m.removedavaliations {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeCartItems:
		ids := make([]ent.Value, 0, len(m.removedcart_items))
		for id := range m.removedcart_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedavaliations {
		edges = append(edges, product.EdgeAvaliations)
	}
	if m.clearedcategory {
		edges = append(edges, product.EdgeCategory)
	}
	if m.clearedorder_items {
		edges = append(edges, product.EdgeOrderItems)
	}
	if m.clearedcart_items {
		edges = append(edges, product.EdgeCartItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeAvaliations:
		return m.clearedavaliations
	case product.EdgeCategory:
		return m.clearedcategory
	case product.EdgeOrderItems:
		return m.clearedorder_items
	case product.EdgeCartItems:
		return m.clearedcart_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeAvaliations:
		m.ResetAvaliations()
		return nil
	case product.EdgeCategory:
		m.ResetCategory()
		return nil
	case product.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case product.EdgeCartItems:
		m.ResetCartItems()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	name               *string
	email              *string
	password           *string
	phone              *string
	profile_image      *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	addresses          map[string]struct{}
	removedaddresses   map[string]struct{}
	clearedaddresses   bool
	orders             map[string]struct{}
	removedorders      map[string]struct{}
	clearedorders      bool
	avaliations        map[string]struct{}
	removedavaliations map[string]struct{}
	clearedavaliations bool
	cart               *string
	clearedcart        bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetProfileImage sets the "profile_image" field.
func (m *UserMutation) SetProfileImage(s string) {
	m.profile_image = &s
}

// ProfileImage returns the value of the "profile_image" field in the mutation.
func (m *UserMutation) ProfileImage() (r string, exists bool) {
	v := m.profile_image
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImage returns the old "profile_image" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfileImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImage: %w", err)
	}
	return oldValue.ProfileImage, nil
}

// ClearProfileImage clears the value of the "profile_image" field.
func (m *UserMutation) ClearProfileImage() {
	m.profile_image = nil
	m.clearedFields[user.FieldProfileImage] = struct{}{}
}

// ProfileImageCleared returns if the "profile_image" field was cleared in this mutation.
func (m *UserMutation) ProfileImageCleared() bool {
	_, ok := m.clearedFields[user.FieldProfileImage]
	return ok
}

// ResetProfileImage resets all changes to the "profile_image" field.
func (m *UserMutation) ResetProfileImage() {
	m.profile_image = nil
	delete(m.clearedFields, user.FieldProfileImage)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *UserMutation) AddAddressIDs(ids ...string) {
	if m.addresses == nil {
		m.addresses = make(map[string]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *UserMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *UserMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *UserMutation) RemoveAddressIDs(ids ...string) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *UserMutation) RemovedAddressesIDs() (ids []string) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *UserMutation) AddressesIDs() (ids []string) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *UserMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *UserMutation) AddOrderIDs(ids ...string) {
	if m.orders == nil {
		m.orders = make(map[string]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *UserMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *UserMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *UserMutation) RemoveOrderIDs(ids ...string) {
	if m.removedorders == nil {
		m.removedorders = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *UserMutation) RemovedOrdersIDs() (ids []string) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *UserMutation) OrdersIDs() (ids []string) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *UserMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddAvaliationIDs adds the "avaliations" edge to the Avaliation entity by ids.
func (m *UserMutation) AddAvaliationIDs(ids ...string) {
	if m.avaliations == nil {
		m.avaliations = make(map[string]struct{})
	}
	for i := range ids {
		m.avaliations[ids[i]] = struct{}{}
	}
}

// ClearAvaliations clears the "avaliations" edge to the Avaliation entity.
func (m *UserMutation) ClearAvaliations() {
	m.clearedavaliations = true
}

// AvaliationsCleared reports if the "avaliations" edge to the Avaliation entity was cleared.
func (m *UserMutation) AvaliationsCleared() bool {
	return m.clearedavaliations
}

// RemoveAvaliationIDs removes the "avaliations" edge to the Avaliation entity by IDs.
func (m *UserMutation) RemoveAvaliationIDs(ids ...string) {
	if m.removedavaliations == nil {
		m.removedavaliations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.avaliations, ids[i])
		m.removedavaliations[ids[i]] = struct{}{}
	}
}

// RemovedAvaliations returns the removed IDs of the "avaliations" edge to the Avaliation entity.
func (m *UserMutation) RemovedAvaliationsIDs() (ids []string) {
	for id := range m.removedavaliations {
		ids = append(ids, id)
	}
	return
}

// AvaliationsIDs returns the "avaliations" edge IDs in the mutation.
func (m *UserMutation) AvaliationsIDs() (ids []string) {
	for id := range m.avaliations {
		ids = append(ids, id)
	}
	return
}

// ResetAvaliations resets all changes to the "avaliations" edge.
func (m *UserMutation) ResetAvaliations() {
	m.avaliations = nil
	m.clearedavaliations = false
	m.removedavaliations = nil
}

// SetCartID sets the "cart" edge to the Cart entity by id.
func (m *UserMutation) SetCartID(id string) {
	m.cart = &id
}

// ClearCart clears the "cart" edge to the Cart entity.
func (m *UserMutation) ClearCart() {
	m.clearedcart = true
}

// CartCleared reports if the "cart" edge to the Cart entity was cleared.
func (m *UserMutation) CartCleared() bool {
	return m.clearedcart
}

// CartID returns the "cart" edge ID in the mutation.
func (m *UserMutation) CartID() (id string, exists bool) {
	if m.cart != nil {
		return *m.cart, true
	}
	return
}

// CartIDs returns the "cart" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CartID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CartIDs() (ids []string) {
	if id := m.cart; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCart resets all changes to the "cart" edge.
func (m *UserMutation) ResetCart() {
	m.cart = nil
	m.clearedcart = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.profile_image != nil {
		fields = append(fields, user.FieldProfileImage)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldProfileImage:
		return m.ProfileImage()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldProfileImage:
		return m.OldProfileImage(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldProfileImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImage(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldProfileImage) {
		fields = append(fields, user.FieldProfileImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldProfileImage:
		m.ClearProfileImage()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldProfileImage:
		m.ResetProfileImage()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.addresses != nil {
		edges = append(edges, user.EdgeAddresses)
	}
	if m.orders != nil {
		edges = append(edges, user.EdgeOrders)
	}
	if m.avaliations != nil {
		edges = append(edges, user.EdgeAvaliations)
	}
	if m.cart != nil {
		edges = append(edges, user.EdgeCart)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAvaliations:
		ids := make([]ent.Value, 0, len(m.avaliations))
		for id := range m.avaliations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCart:
		if id := m.cart; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedaddresses != nil {
		edges = append(edges, user.EdgeAddresses)
	}
	if m.removedorders != nil {
		edges = append(edges, user.EdgeOrders)
	}
	if m.removedavaliations != nil {
		edges = append(edges, user.EdgeAvaliations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAvaliations:
		ids := make([]ent.Value, 0, len(m.removedavaliations))
		for id := range m.removedavaliations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaddresses {
		edges = append(edges, user.EdgeAddresses)
	}
	if m.clearedorders {
		edges = append(edges, user.EdgeOrders)
	}
	if m.clearedavaliations {
		edges = append(edges, user.EdgeAvaliations)
	}
	if m.clearedcart {
		edges = append(edges, user.EdgeCart)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAddresses:
		return m.clearedaddresses
	case user.EdgeOrders:
		return m.clearedorders
	case user.EdgeAvaliations:
		return m.clearedavaliations
	case user.EdgeCart:
		return m.clearedcart
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCart:
		m.ClearCart()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case user.EdgeOrders:
		m.ResetOrders()
		return nil
	case user.EdgeAvaliations:
		m.ResetAvaliations()
		return nil
	case user.EdgeCart:
		m.ResetCart()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
